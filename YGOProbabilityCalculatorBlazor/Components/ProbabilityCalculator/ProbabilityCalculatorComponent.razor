@using YGOProbabilityCalculatorBlazor.Models
@using YGOProbabilityCalculatorBlazor.Services.DeckImport
@using YGOProbabilityCalculatorBlazor.Services.Interface
@using YGOProbabilityCalculatorBlazor.Services.ProbabilityCalculator
@implements IDisposable
@inject DeckImportService _deckImportService
@inject ISessionService _sessionService

<div class="container">
    <div class="d-flex align-items-center mb-4">
        <h3 class="mb-0 me-3">Probability Calculator</h3>
        <div class="d-flex align-items-center me-3">
            <label for="handSize" class="me-2 mb-0">Hand Size:</label>
            <input type="number"
                   id="handSize"
                   class="form-control"
                   style="width: 80px;"
                   @bind="handSize"
                   min="1"/>
        </div>
        <button class="btn btn-primary">
            <InputFile OnChange="@ImportDeckAsync" accept=".ydk" class="d-none" id="fileInput"/>
            <label for="fileInput" class="m-0" style="cursor: pointer;">Import Deck</label>
        </button>
        <button class="btn btn-secondary ms-2" @onclick="SaveCurrentSession">
            Save Session
        </button>
        <button class="btn btn-secondary ms-2">
            <InputFile OnChange="@LoadSessionFile" accept=".json" class="d-none" id="sessionFileInput"/>
            <label for="sessionFileInput" class="m-0" style="cursor: pointer;">Load Session</label>
        </button>
    </div>
    @if (importError is not null) {
        <div class="alert alert-danger mt-2" role="alert">
            @importError
        </div>
    }

    <div class="mb-4">
        <h4>Category Definitions</h4>
        <div class="row">
            <div class="col-4">
                <input @bind="newCategoryName" class="form-control" placeholder="Category name"/>
            </div>
            <div class="col-2">
                <button class="btn btn-primary" @onclick="AddCategoryBase">Add Category</button>
            </div>
        </div>
        @if (categoryError is not null) {
            <div class="alert alert-danger mt-2" role="alert">
                @categoryError
            </div>
        }
        <div class="mt-2">
            @foreach (var category in categoryBases) {
                <span class="badge bg-secondary me-2">
                    @category.Name
                    <button type="button" class="btn-close btn-close-white" aria-label="Close"
                            @onclick="() => RemoveCategoryBase(category)"></button>
                </span>
            }
        </div>
    </div>

    <div class="mb-4">
        <h4>Cards (@cards.Sum(c => c.Copies))</h4>
        @if (cardError is not null) {
            <div class="alert alert-danger mb-2" role="alert">
                @cardError
            </div>
        }
        <div class="accordion" id="cardsAccordion">
            @foreach (var (card, index) in cards.Select((c, i) => (c, i))) {
                <div class="accordion-item">
                    <h2 class="accordion-header d-flex">
                        <button class="accordion-button flex-grow-1 @(index == activeCardIndex ? "" : "collapsed")"
                                type="button"
                                data-bs-toggle="collapse"
                                data-bs-target="#card@(index)"
                                @onclick="() => ToggleCard(index)">
                            @if (string.IsNullOrEmpty(card.Name)) {
                                <span>Card @(index + 1)</span>
                            }
                            else {
                                <span>@card.Name</span>
                            }
                            <span class="ms-2">(@card.Copies copies)</span>
                            @if (card.Categories.Any()) {
                                <span class="ms-2">-</span>
                                @foreach (var cat in card.Categories) {
                                    <span class="badge bg-info ms-1">@cat.Name</span>
                                }
                            }
                        </button>
                        <button class="btn btn-danger" @onclick="() => RemoveCard(index)">
                            <i class="bi bi-trash"></i>
                        </button>
                    </h2>
                    <div id="card@(index)"
                         class="accordion-collapse collapse @(index == activeCardIndex ? "show" : "")"
                         data-parent="">
                        <div class="accordion-body">
                            <div class="row mb-3">
                                <div class="col-4">
                                    <input type="text"
                                           class="form-control"
                                           placeholder="Card name"
                                           value="@card.Name"
                                           @onchange="@(e => UpdateCardName(index, e.Value?.ToString()))"/>
                                </div>
                                <div class="col-2">
                                    <input type="number"
                                           class="form-control"
                                           placeholder="Copies"
                                           min="1"
                                           value="@card.Copies"
                                           @onchange="@(e => UpdateCardCopies(index, int.Parse(e.Value?.ToString() ?? "1")))"/>
                                </div>
                                <div class="col-4">
                                    <select class="form-select" @bind="cardEditStates[index].SelectedCategory">
                                        <option value="">Add category...</option>
                                        @foreach (var cat in categoryBases.Where(c => !card.Categories.Contains(c))) {
                                            <option value="@cat.Name">@cat.Name</option>
                                        }
                                    </select>
                                </div>
                                <div class="col-2">
                                    <button class="btn btn-primary"
                                            @onclick="() => AddCategoryToCard(index)">
                                        Add Category
                                    </button>
                                </div>
                            </div>
                            <div>
                                @foreach (var category in card.Categories) {
                                    <span class="badge bg-info me-2">
                                        @category.Name
                                        <button type="button"
                                                class="btn-close btn-close-white"
                                                aria-label="Close"
                                                @onclick="() => RemoveCategoryFromCard(index, category)">
                                        </button>
                                    </span>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>
        <div class="mt-3">
            <button class="btn btn-primary" @onclick="AddNewCard">Add New Card</button>
        </div>
    </div>

    <div class="mb-4">
        <h4>Combos</h4>
        @if (comboError is not null) {
            <div class="alert alert-danger mb-2" role="alert">
                @comboError
            </div>
        }
        <div class="accordion" id="combosAccordion">
            @foreach (var (combo, index) in combos.Select((c, i) => (c, i))) {
                <div class="accordion-item">
                    <h2 class="accordion-header d-flex">
                        <button class="accordion-button flex-grow-1 @(index == activeComboIndex ? "" : "collapsed")"
                                type="button"
                                data-bs-toggle="collapse"
                                data-bs-target="#combo@(index)"
                                @onclick="() => ToggleCombo(index)">
                            @if (string.IsNullOrEmpty(combo.Name)) {
                                <span>Combo @(index + 1)</span>
                            }
                            else {
                                <span>@combo.Name</span>
                            }
                            @if (combo.Categories.Any()) {
                                <span class="ms-2">-</span>
                                @foreach (var cat in combo.Categories) {
                                    <span class="badge bg-info ms-1">
                                        @cat.BaseCategory.Name (@cat.MinCount-@cat.MaxCount)
                                    </span>
                                }
                            }
                        </button>
                        <button class="btn btn-danger" @onclick="() => RemoveCombo(index)">
                            <i class="bi bi-trash"></i>
                        </button>
                    </h2>
                    <div id="combo@(index)"
                         class="accordion-collapse collapse @(index == activeComboIndex ? "show" : "")"
                         data-parent="">
                        <div class="accordion-body">
                            <div class="row mb-3">
                                <div class="col-4">
                                    <input type="text"
                                           class="form-control"
                                           placeholder="Combo name"
                                           value="@combo.Name"
                                           @onchange="@(e => UpdateComboName(index, e.Value?.ToString()))"/>
                                </div>
                            </div>
                            <div class="row mb-3">
                                <div class="col-4">
                                    <select class="form-select" @bind="comboEditStates[index].SelectedCategory">
                                        <option value="">Select category...</option>
                                        @foreach (var cat in categoryBases) {
                                            <option value="@cat.Name">@cat.Name</option>
                                        }
                                    </select>
                                </div>
                                <div class="col-2">
                                    <input @bind="comboEditStates[index].MinCount"
                                           type="number"
                                           class="form-control"
                                           placeholder="Min"/>
                                </div>
                                <div class="col-2">
                                    <input @bind="comboEditStates[index].MaxCount"
                                           type="number"
                                           class="form-control"
                                           placeholder="Max"/>
                                </div>
                                <div class="col-2">
                                    <button class="btn btn-primary"
                                            @onclick="() => AddCategoryToCombo(index)">
                                        Add to Combo
                                    </button>
                                </div>
                            </div>
                            <div>
                                @foreach (var category in combo.Categories) {
                                    <span class="badge bg-info me-2">
                                        @category.BaseCategory.Name (@category.MinCount-@category.MaxCount)
                                        <button type="button"
                                                class="btn-close btn-close-white"
                                                aria-label="Close"
                                                @onclick="() => RemoveCategoryFromCombo(index, category)">
                                        </button>
                                    </span>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>
        <div class="mt-3">
            <button class="btn btn-primary" @onclick="AddNewCombo">Add New Combo</button>
        </div>
    </div>

    <div class="results-section">
        <div class="col-3">
            <button class="btn btn-primary btn-lg w-100"
                    @onclick="Calculate"
                    disabled="@(isCalculating || !CanCalculate)">
                @if (isCalculating) {
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    <span class="ms-1">Calculating...</span>
                }
                else {
                    <span>Calculate</span>
                }
            </button>
        </div>

        @if (errorMessage is not null) {
            <div class="alert alert-danger mt-3" role="alert">
                @errorMessage
            </div>
        }

        @if (probability is not null) {
            <div class="alert alert-primary mt-3" role="alert">
                <h5>Results:</h5>
                <p class="mb-0">Probability: @(probability.Value.ToString("P2"))</p>
            </div>
        }
    </div>
</div>

@code {

    private record CardEditState {
        public string SelectedCategory { get; set; } = "";
    }

    private record ComboEditState {
        public string SelectedCategory { get; set; } = "";
        public int MinCount { get; set; } = 1;
        public int MaxCount { get; set; }
    }

    private string? categoryError;
    private string? cardError;
    private string? comboError;

    private string newCategoryName = "";
    private readonly List<CategoryBase> categoryBases = [];
    private readonly List<Card> cards = [];
    private readonly List<Combo> combos = [];
    private readonly List<CardEditState> cardEditStates = [];
    private readonly List<ComboEditState> comboEditStates = [];

    private int activeComboIndex = -1;
    private int activeCardIndex = -1;

    private int handSize = 5;
    private bool isCalculating;
    private string? errorMessage;
    private string? importError;
    private double? probability;
    private readonly CancellationTokenSource cts = new();

    private bool CanCalculate =>
        cards.Count > 0 &&
        handSize > 0 &&
        handSize <= cards.Sum(c => c.Copies) &&
        combos.Count > 0 &&
        combos.All(c => c.Categories.Count > 0);

    private void ToggleCard(int index) {
        if (activeCardIndex == index) {
            activeCardIndex = -1;
        }
        else {
            SetActiveCard(index);
        }
    }

    private void SetActiveCard(int index) {
        activeCardIndex = index;
        while (cardEditStates.Count <= index) {
            cardEditStates.Add(new CardEditState());
        }
    }

    private void ToggleCombo(int index) {
        if (activeComboIndex == index) {
            activeComboIndex = -1;
        }
        else {
            SetActiveCombo(index);
        }
    }

    private void SetActiveCombo(int index) {
        activeComboIndex = index;
        while (comboEditStates.Count <= index) {
            comboEditStates.Add(new ComboEditState());
        }
    }

    private async Task Calculate() {
        if (!CanCalculate) return;

        try {
            isCalculating = true;
            errorMessage = null;
            probability = null;
            StateHasChanged();

            probability = await Task.Run(() => ProbabilityCalculator.CalculateProbabilityForCombos(
                cards,
                combos,
                handSize,
                cts.Token
            ), cts.Token);
        }
        catch (OperationCanceledException) {
            errorMessage = "Calculation was cancelled.";
        }
        finally {
            isCalculating = false;
        }
    }

    private void AddCategoryBase() {
        if (string.IsNullOrWhiteSpace(newCategoryName)) {
            categoryError = "Category name cannot be empty.";
            return;
        }

        try {
            if (categoryBases.Any(c => c.Name.Equals(newCategoryName, StringComparison.OrdinalIgnoreCase))) {
                categoryError = "A category with this name already exists.";
                return;
            }

            var categoryBase = new CategoryBase(newCategoryName);
            categoryBases.Add(categoryBase);
            newCategoryName = "";
            categoryError = null;
        }
        catch (ArgumentException ex) {
            categoryError = ex.Message;
        }
    }

    private void RemoveCategoryBase(CategoryBase category) {
        if (!combos.Any(c => c.Categories.Any(cc => cc.BaseCategory == category)) &&
            !cards.Any(c => c.Categories.Contains(category))) {
            categoryBases.Remove(category);
        }
    }

    private void AddNewCard() {
        cards.Add(new Card([]));
        cardEditStates.Add(new CardEditState());
        SetActiveCard(cards.Count - 1);
    }

    private void RemoveCard(int index) {
        if (index < 0 || index >= cards.Count) return;
        cards.RemoveAt(index);
        cardEditStates.RemoveAt(index);
        if (activeCardIndex >= cards.Count) {
            activeCardIndex = cards.Count - 1;
        }
    }

    private void UpdateCardCopies(int cardIndex, int copies) {
        try {
            if (copies < 1) {
                cardError = "Number of copies must be at least 1.";
                return;
            }

            var oldCard = cards[cardIndex];
            cards[cardIndex] = oldCard.WithCopies(copies);
            cardError = null;
        }
        catch (ArgumentException ex) {
            cardError = ex.Message;
        }
    }

    private void UpdateCardName(int cardIndex, string? name) {
        var oldCard = cards[cardIndex];
        cards[cardIndex] = oldCard.WithName(name);
    }

    private void AddCategoryToCard(int cardIndex) {
        var selectedCategory = cardEditStates[cardIndex].SelectedCategory;
        if (string.IsNullOrEmpty(selectedCategory)) {
            cardError = "Please select a category to add.";
            return;
        }

        var categoryBase = categoryBases.FirstOrDefault(c => c.Name == selectedCategory);
        if (categoryBase == null) {
            cardError = "Selected category not found.";
            return;
        }

        var oldCard = cards[cardIndex];
        if (oldCard.Categories.Contains(categoryBase)) {
            cardError = "This category is already added to the card.";
            return;
        }

        cards[cardIndex] = oldCard.WithCategories(oldCard.Categories.Concat([categoryBase]));
        cardEditStates[cardIndex].SelectedCategory = "";
        cardError = null;
    }

    private void RemoveCategoryFromCard(int cardIndex, CategoryBase category) {
        var oldCard = cards[cardIndex];
        cards[cardIndex] = oldCard.WithCategories(oldCard.Categories.Where(c => c != category));
    }

    private void AddNewCombo() {
        combos.Add(new Combo([]));
        comboEditStates.Add(new ComboEditState { MaxCount = handSize });
        SetActiveCombo(combos.Count - 1);
    }

    private void RemoveCombo(int index) {
        if (index < 0 || index >= combos.Count) return;
        combos.RemoveAt(index);
        comboEditStates.RemoveAt(index);
        if (activeComboIndex >= combos.Count) {
            activeComboIndex = combos.Count - 1;
        }
    }

    private void UpdateComboName(int comboIndex, string? name) {
        var oldCombo = combos[comboIndex];
        combos[comboIndex] = new Combo(oldCombo.Categories, name);
    }

    private void AddCategoryToCombo(int comboIndex) {
        var state = comboEditStates[comboIndex];
        if (string.IsNullOrEmpty(state.SelectedCategory)) {
            comboError = "Please select a category to add.";
            return;
        }

        var categoryBase = categoryBases.FirstOrDefault(c => c.Name == state.SelectedCategory);
        if (categoryBase == null) {
            comboError = "Selected category not found.";
            return;
        }

        try {
            if (state.MinCount < 0) {
                comboError = "Minimum count cannot be negative.";
                return;
            }

            if (state.MaxCount < state.MinCount) {
                comboError = "Maximum count cannot be less than minimum count.";
                return;
            }

            var comboCategory = new ComboCategory(categoryBase, state.MinCount, state.MaxCount);
            var combo = combos[comboIndex];

            var existingIndex = combo.Categories.FindIndex(c => c.BaseCategory.Name == categoryBase.Name);
            if (existingIndex >= 0) {
                combo.Categories[existingIndex] = comboCategory;
            }
            else {
                combo.Categories.Add(comboCategory);
            }

            state.SelectedCategory = "";
            state.MinCount = 1;
            state.MaxCount = handSize;
            comboError = null;
        }
        catch (ArgumentException ex) {
            comboError = ex.Message;
        }
    }

    private async Task ImportDeckAsync(InputFileChangeEventArgs e) {
        try {
            importError = null;
            var file = e.File;
            var tempPath = Path.GetTempFileName();

            await using (var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024)) // 1MB max
            await using (var fileStream = File.Create(tempPath)) {
                await stream.CopyToAsync(fileStream);
            }

            var importedCards = await _deckImportService.ImportDeckFromYdkAsync(tempPath);

            cards.Clear();
            cards.AddRange(importedCards);

            cardEditStates.Clear();
            for (var i = 0; i < cards.Count; i++) {
                cardEditStates.Add(new CardEditState());
            }

            File.Delete(tempPath);
        }
        catch (Exception ex) {
            importError = $"Failed to import deck: {ex.Message}";
        }
    }

    private void RemoveCategoryFromCombo(int comboIndex, ComboCategory category) {
        combos[comboIndex].Categories.Remove(category);
    }

    private async Task SaveSession(string fileName) {
        try {
            var session = new SessionState {
                Categories = categoryBases,
                Cards = cards,
                Combos = combos,
                HandSize = handSize
            };

            await _sessionService.SaveSessionAsync(session, fileName);
        }
        catch (Exception ex) {
            errorMessage = $"Failed to save session: {ex.Message}";
        }
    }

    private async Task LoadSessionFile(InputFileChangeEventArgs e) {
        try {
            var file = e.File;
            using var streamReader = new StreamReader(file.OpenReadStream());
            var fileContent = await streamReader.ReadToEndAsync();

            var session = await _sessionService.LoadSessionAsync(fileContent);

            categoryBases.Clear();
            categoryBases.AddRange(session.Categories);

            cards.Clear();
            cards.AddRange(session.Cards);

            combos.Clear();
            combos.AddRange(session.Combos);

            handSize = session.HandSize;

            cardEditStates.Clear();
            for (var i = 0; i < cards.Count; i++) {
                cardEditStates.Add(new CardEditState());
            }

            comboEditStates.Clear();
            for (var i = 0; i < combos.Count; i++) {
                comboEditStates.Add(new ComboEditState());
            }

            errorMessage = null;
        }
        catch (Exception ex) {
            errorMessage = $"Failed to load session: {ex.Message}";
        }
    }

    private async Task SaveCurrentSession() {
        var fileName = $"calculator_session_{DateTime.Now:yyyyMMdd_HHmmss}.json";
        await SaveSession(fileName);
    }

    void IDisposable.Dispose() {
        cts.Cancel();
        cts.Dispose();
    }

}